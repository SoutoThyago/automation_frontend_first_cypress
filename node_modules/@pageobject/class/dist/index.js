"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `import {PageObject} from '@pageobject/class';`
 */
class PageObject {
    constructor(adapter, options = {}) {
        /* tslint:disable-next-line no-any */
        const { constructor } = this;
        if (typeof constructor.selector !== 'string') {
            throw new Error('Missing selector');
        }
        this._Component = constructor;
        this._adapter = adapter;
        this._options = options;
    }
    static selectRoot(Component, adapter, predicate) {
        return new Component(adapter, { predicate });
    }
    async getNumberOfDescendants(Component, predicate) {
        const component = this.selectDescendant(Component, predicate);
        const elements = await component._findElements();
        return elements.length;
    }
    selectDescendant(Component, predicate) {
        return new Component(this._adapter, { parent: this, predicate });
    }
    async click(options = { scrollIntoView: true }) {
        const { scrollIntoView } = Object.assign({ scrollIntoView: true }, options);
        if (scrollIntoView) {
            await this._scrollIntoView();
        }
        await this._adapter.click(await this._findElement());
    }
    async focus() {
        await this._adapter.evaluate((_element) => _element.focus(), await this._findElement());
    }
    async type(text, options = { delay: 100 }) {
        const { delay } = Object.assign({ delay: 100 }, options);
        await this._adapter.type(await this._findElement(), text, delay);
    }
    async getAttribute(name) {
        return this._adapter.evaluate((_element, _name) => (_element.getAttribute(_name) || '').trim(), await this._findElement(), name);
    }
    async getHtml() {
        return this._adapter.evaluate((_element) => _element.innerHTML.trim(), await this._findElement());
    }
    async getProperty(name) {
        return this._adapter.evaluate((_element, _name) => _element[_name], await this._findElement(), name);
    }
    async setProperty(name, value) {
        await this._adapter.evaluate((_element, _name, _value) => (_element[_name] = _value), await this._findElement(), name, value);
    }
    async getTagName() {
        return this._adapter.evaluate((_element) => _element.tagName.trim(), await this._findElement());
    }
    async getText() {
        return this._adapter.evaluate((_element) => _element.innerText.trim(), await this._findElement());
    }
    async getUrl() {
        return this._adapter.evaluate(() => window.location.href.trim());
    }
    /* https://stackoverflow.com/a/36737835 */
    async isVisible() {
        return this._adapter.evaluate((_element) => {
            if (!_element.offsetHeight && !_element.offsetWidth) {
                return false;
            }
            if (getComputedStyle(_element).visibility === 'hidden') {
                return false;
            }
            return true;
        }, await this._findElement());
    }
    async waitUntil(action, callback) {
        const maybeTimeout = process.env.WAIT_TIMEOUT;
        const timeout = maybeTimeout ? parseInt(maybeTimeout, 10) : 10000;
        let error = new Error(`Timeout after ${timeout} milliseconds`);
        let expired = false;
        /* tslint:disable no-any */
        let timeoutId1;
        let timeoutId2;
        /* tslint:enable no-any */
        return Promise.race([
            (async () => {
                while (!expired) {
                    try {
                        await action(this) /* tslint:disable-line no-any */;
                        clearTimeout(timeoutId2);
                        return this;
                    }
                    catch (e) {
                        error = e;
                    }
                    await new Promise(resolve => {
                        timeoutId1 = setTimeout(resolve, 40);
                    });
                }
                await callback(await this._adapter.takeScreenshot());
                /* istanbul ignore next */
                throw error;
            })(),
            (async () => {
                await new Promise(resolve => {
                    timeoutId2 = setTimeout(resolve, timeout);
                });
                expired = true;
                clearTimeout(timeoutId1);
                await callback(await this._adapter.takeScreenshot());
                throw error;
            })()
        ]);
    }
    toString() {
        const { parent } = this._options;
        const name = `${this.constructor.name}[${this._Component.selector}]`;
        return parent ? `${parent.toString()} > ${name}` : name;
    }
    async _findElement() {
        const { element } = this._options;
        if (element) {
            return element;
        }
        const elements = await this._findElements();
        if (elements.length === 0) {
            throw new Error(`Element not found: ${this.toString()}`);
        }
        if (elements.length > 1) {
            throw new Error(`Element not unique: ${this.toString()}`);
        }
        return elements[0];
    }
    async _findElements() {
        const Component = this._Component;
        const adapter = this._adapter;
        const options = this._options;
        const { parent, predicate } = options;
        const elements = await adapter.findElements(Component.selector, parent && (await parent._findElement()));
        if (!predicate) {
            return elements;
        }
        const results = await Promise.all(elements
            .map(element => new Component(adapter, Object.assign({}, options, { element })))
            .map(predicate));
        return elements.filter((element, index) => results[index]);
    }
    async _scrollIntoView() {
        await this._adapter.evaluate((_element) => _element.scrollIntoView({
            behavior: 'instant',
            block: 'center',
            inline: 'center'
        }), await this._findElement());
        await new Promise(resolve => setTimeout(resolve, 100));
    }
}
exports.PageObject = PageObject;
//# sourceMappingURL=index.js.map